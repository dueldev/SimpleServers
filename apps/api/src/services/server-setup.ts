import fs from "node:fs";
import path from "node:path";
import { downloadToFile } from "../lib/download.js";
import type { ServerRecord, ServerType } from "../domain/types.js";
import { VersionCatalogService } from "./version-catalog.js";

export type SetupInput = {
  id: string;
  name: string;
  type: ServerType;
  mcVersion: string;
  rootPath: string;
  port: number;
  allowCracked: boolean;
  enableGeyser: boolean;
  enableFloodgate: boolean;
};

function writeIfMissing(filePath: string, content: string): void {
  if (!fs.existsSync(filePath)) {
    fs.writeFileSync(filePath, content, "utf8");
  }
}

function createServerProperties(input: SetupInput): string {
  return [
    "# Generated by SimpleServers",
    `motd=SimpleServers - ${input.name}`,
    "enable-command-block=true",
    "view-distance=10",
    "simulation-distance=10",
    `online-mode=${input.allowCracked ? "false" : "true"}`,
    "white-list=false",
    "spawn-protection=0",
    `server-port=${input.port}`,
    "difficulty=normal",
    "gamemode=survival"
  ].join("\n");
}

export class ServerSetupService {
  constructor(private readonly versions: VersionCatalogService) {}

  async provisionServer(input: SetupInput): Promise<{ jarPath: string }> {
    fs.mkdirSync(input.rootPath, { recursive: true });

    const jarPath = path.join(input.rootPath, "server.jar");
    const jarUrl = await this.resolveJarUrl(input.type, input.mcVersion);
    await downloadToFile(jarUrl, jarPath);

    writeIfMissing(path.join(input.rootPath, "eula.txt"), "eula=true\n");
    writeIfMissing(path.join(input.rootPath, "server.properties"), createServerProperties(input));
    writeIfMissing(path.join(input.rootPath, "ops.json"), "[]\n");
    writeIfMissing(path.join(input.rootPath, "whitelist.json"), "[]\n");

    if (input.type === "paper") {
      await this.installPaperEnhancements(input);
    }

    return { jarPath };
  }

  private async resolveJarUrl(type: ServerType, version: string): Promise<string> {
    if (type === "vanilla") {
      return this.versions.resolveVanillaServerJar(version);
    }

    if (type === "paper") {
      return this.versions.resolvePaperServerJar(version);
    }

    return this.versions.resolveFabricServerJar(version);
  }

  private async installPaperEnhancements(input: SetupInput): Promise<void> {
    const pluginsDir = path.join(input.rootPath, "plugins");
    fs.mkdirSync(pluginsDir, { recursive: true });

    if (input.enableGeyser) {
      await downloadToFile(
        "https://download.geysermc.org/v2/projects/geyser/versions/latest/builds/latest/downloads/spigot",
        path.join(pluginsDir, "Geyser-Spigot.jar")
      );
    }

    if (input.enableFloodgate) {
      await downloadToFile(
        "https://download.geysermc.org/v2/projects/floodgate/versions/latest/builds/latest/downloads/spigot",
        path.join(pluginsDir, "floodgate-spigot.jar")
      );
    }
  }

  buildLaunchCommand(server: ServerRecord): { executable: string; args: string[] } {
    const args = [
      `-Xms${server.minMemoryMb}M`,
      `-Xmx${server.maxMemoryMb}M`,
      "-Dterminal.jline=false",
      "-Dterminal.ansi=true",
      "-jar",
      path.basename(server.jarPath),
      "nogui"
    ];

    return {
      executable: server.javaPath,
      args
    };
  }
}
